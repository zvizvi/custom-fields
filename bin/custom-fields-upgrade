#!/usr/bin/env php
<?php

/**
 * Custom Fields v1 to v2 Upgrade Script
 *
 * This standalone script upgrades your codebase from Custom Fields v1 to v2.
 * Updates imports, component usage, and provides configuration guidance.
 * Runs without requiring Laravel bootstrap (avoiding autoload conflicts).
 *
 * Usage: vendor/bin/custom-fields-upgrade [--path=/path/to/scan]
 */

// Parse command line arguments
$options = getopt('', ['path::', 'help', 'dry-run', 'backup', 'verbose']);

if (isset($options['help'])) {
    echo "\033[36mCustom Fields v1 to v2 Upgrade Script\033[0m\n";
    echo "=====================================\n\n";
    echo "Usage: \033[33mvendor/bin/custom-fields-upgrade\033[0m [options]\n\n";
    echo "Options:\n";
    echo "  \033[32m--path=PATH\033[0m    Specific path to upgrade (defaults to app directory)\n";
    echo "  \033[32m--dry-run\033[0m      Show what would be changed without making changes\n";
    echo "  \033[32m--backup\033[0m       Create backup files before making changes\n";
    echo "  \033[32m--verbose\033[0m      Show detailed progress information\n";
    echo "  \033[32m--help\033[0m         Show this help message\n\n";
    echo "Examples:\n";
    echo "  vendor/bin/custom-fields-upgrade                    # Upgrade app directory\n";
    echo "  vendor/bin/custom-fields-upgrade --dry-run          # Preview changes\n";
    echo "  vendor/bin/custom-fields-upgrade --backup           # Create backups\n";
    echo "  vendor/bin/custom-fields-upgrade --path=app/Filament # Specific path\n\n";
    exit(0);
}

$dryRun = isset($options['dry-run']);
$createBackup = isset($options['backup']);
$verbose = isset($options['verbose']);

// Determine the path to scan
$basePath = getcwd();
$scanPath = $options['path'] ?? $basePath . '/app';

// If a custom path is provided, derive the project root
if (isset($options['path'])) {
    // Try to find the project root by looking for composer.json or config directory
    $checkPath = dirname($scanPath);
    while ($checkPath !== '/' && $checkPath !== $basePath) {
        if (file_exists($checkPath . '/composer.json') || file_exists($checkPath . '/config')) {
            $basePath = $checkPath;
            break;
        }
        $checkPath = dirname($checkPath);
    }
}

if (! is_dir($scanPath)) {
    echo "‚ùå Error: Directory not found: $scanPath\n";
    exit(1);
}

echo "üöÄ Custom Fields Upgrade Tool (V1 ‚Üí V2)\n";
echo "=====================================\n\n";

if ($dryRun) {
    echo "üîç DRY RUN MODE - No files will be modified\n";
}
if ($createBackup) {
    echo "üíæ BACKUP MODE - Creating backups before changes\n";
}

echo "üìÅ Scanning directory: $scanPath\n\n";

/**
 * Create backup of a file
 */
function createBackupFile($filePath) {
    $backupPath = $filePath . '.v1-backup-' . date('Y-m-d-H-i-s');
    if (copy($filePath, $backupPath)) {
        return $backupPath;
    }
    return false;
}

/**
 * Show progress for large file operations
 */
function showProgress($current, $total, $message = '') {
    if ($total > 10) { // Only show progress for larger operations
        $percentage = round(($current / $total) * 100);
        $bar = str_repeat('‚ñà', intval($percentage / 5));
        $spaces = str_repeat(' ', 20 - intval($percentage / 5));
        echo "\rüîÑ Progress: [$bar$spaces] {$percentage}% ($current/$total) $message";
        if ($current == $total) {
            echo "\n";
        }
    }
}

// Import pattern upgrades
$importPatterns = [
    // Form component imports
    [
        'pattern' => '/use\s+Relaticle\\\\CustomFields\\\\Filament\\\\Forms\\\\Components\\\\CustomFieldsComponent;/',
        'replacement' => 'use Relaticle\CustomFields\Facades\CustomFields;',
        'description' => 'Form component import',
    ],
    // Infolist component imports
    [
        'pattern' => '/use\s+Relaticle\\\\CustomFields\\\\Filament\\\\Infolists\\\\CustomFieldsInfolists;/',
        'replacement' => 'use Relaticle\CustomFields\Facades\CustomFields;',
        'description' => 'Infolist component import',
    ],
    // Import/Export component imports
    [
        'pattern' => '/use\s+Relaticle\\\\CustomFields\\\\Filament\\\\Imports\\\\CustomFieldsImporter;/',
        'replacement' => 'use Relaticle\CustomFields\Facades\CustomFields;',
        'description' => 'Import component import',
    ],
    [
        'pattern' => '/use\s+Relaticle\\\\CustomFields\\\\Filament\\\\Exports\\\\CustomFieldsExporter;/',
        'replacement' => 'use Relaticle\CustomFields\Facades\CustomFields;',
        'description' => 'Export component import',
    ],
    // Trait namespace update
    [
        'pattern' => '/use\s+Relaticle\\\\CustomFields\\\\Filament\\\\Tables\\\\Concerns\\\\InteractsWithCustomFields;/',
        'replacement' => 'use Relaticle\CustomFields\Concerns\InteractsWithCustomFields;',
        'description' => 'Table trait namespace',
    ],
];

// Complex component usage patterns (handles multiline and chaining)
$complexPatterns = [
    // Form component with potential chaining - handles multiline
    [
        'pattern' => '/CustomFieldsComponent::make\(\)(?:\s*->[a-zA-Z_][a-zA-Z0-9_]*\([^)]*\))*\s*(?:,|\]|\)|;)/',
        'replacement' => function($matches) {
            $original = $matches[0];
            $endChar = substr(trim($original), -1);
            
            // Extract any chained methods after make()
            preg_match('/CustomFieldsComponent::make\(\)(.*?)(?:,|\]|\)|;)/', $original, $chainMatches);
            $chainedMethods = isset($chainMatches[1]) ? trim($chainMatches[1]) : '';
            
            return 'CustomFields::form()
                ->forModel($form->getRecord())
                ->build()' . $chainedMethods . $endChar;
        },
        'description' => 'Form component usage (with chaining)',
        'requiresImport' => 'Relaticle\CustomFields\Facades\CustomFields',
    ],
    
    // Infolist component with chaining - handles multiline  
    [
        'pattern' => '/CustomFieldsInfolists::make\(\)(?:\s*->[a-zA-Z_][a-zA-Z0-9_]*\([^)]*\))*\s*(?:,|\]|\)|;)/',
        'replacement' => function($matches) {
            $original = $matches[0];
            $endChar = substr(trim($original), -1);
            
            // Extract chained methods
            preg_match('/CustomFieldsInfolists::make\(\)(.*?)(?:,|\]|\)|;)/', $original, $chainMatches);
            $chainedMethods = isset($chainMatches[1]) ? trim($chainMatches[1]) : '';
            
            return 'CustomFields::infolist()
                ->forModel($infolist->getRecord())
                ->build()' . $chainedMethods . $endChar;
        },
        'description' => 'Infolist component usage (with chaining)', 
        'requiresImport' => 'Relaticle\CustomFields\Facades\CustomFields',
    ],
];

// Import/Export usage patterns
$importExportPatterns = [
    // CustomFieldsImporter usage in getColumns
    [
        'pattern' => '/\.\.\.app\(CustomFieldsImporter::class\)->getColumns\(([^)]+)\)/',
        'replacement' => '...CustomFields::importer()
            ->forModel($1)
            ->columns()',
        'description' => 'Importer getColumns usage',
        'requiresImport' => 'Relaticle\CustomFields\Facades\CustomFields',
    ],
    
    // CustomFieldsImporter usage in getColumnsByFieldCodes (multiline)
    [
        'pattern' => '/\.\.\.app\(CustomFieldsImporter::class\)->getColumnsByFieldCodes\(\s*([^,\s]+),\s*(\[[^\]]+\])\s*\)/',
        'replacement' => '...CustomFields::importer()
            ->forModel($1)
            ->only($2)
            ->columns()',
        'description' => 'Importer getColumnsByFieldCodes usage',
        'requiresImport' => 'Relaticle\CustomFields\Facades\CustomFields',
    ],

    // CustomFieldsImporter filterCustomFieldsFromData
    [
        'pattern' => '/app\(CustomFieldsImporter::class\)->filterCustomFieldsFromData\(([^)]+)\)/',
        'replacement' => 'CustomFields::importer()->filterCustomFieldsFromData($1)',
        'description' => 'Importer filterCustomFieldsFromData usage',
        'requiresImport' => 'Relaticle\CustomFields\Facades\CustomFields',
    ],

    // CustomFieldsImporter saveCustomFieldValues
    [
        'pattern' => '/app\(CustomFieldsImporter::class\)->saveCustomFieldValues\(([^;]+)\);/',
        'replacement' => function($matches) {
            $params = trim($matches[1]);
            // Parse parameters - typically record, data, tenant
            $paramArray = array_map('trim', explode(',', $params));
            
            if (count($paramArray) >= 2) {
                return 'CustomFields::importer()
            ->forModel(' . $paramArray[0] . ')
            ->saveCustomFieldValues(' . implode(', ', $paramArray) . ');';
            }
            return $matches[0]; // Fallback if parsing fails
        },
        'description' => 'Importer saveCustomFieldValues usage',
        'requiresImport' => 'Relaticle\CustomFields\Facades\CustomFields',
    ],

    // CustomFieldsExporter getColumns usage
    [
        'pattern' => '/\.\.\.CustomFieldsExporter::getColumns\(([^)]+)\)/',
        'replacement' => '...CustomFields::exporter()
            ->forModel($1)
            ->columns()',
        'description' => 'Exporter getColumns usage',
        'requiresImport' => 'Relaticle\CustomFields\Facades\CustomFields',
    ],
];

// Find all PHP files
$files = [];
$iterator = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($scanPath, RecursiveDirectoryIterator::SKIP_DOTS)
);

foreach ($iterator as $file) {
    if ($file->isFile() && $file->getExtension() === 'php') {
        $files[] = $file->getPathname();
    }
}

echo 'Found ' . count($files) . " PHP files to scan\n\n";

// Upgrade configuration file first
$configUpgraded = upgradeConfigurationFile($basePath, $dryRun, $createBackup, $verbose);

$filesUpdated = [];
$errors = [];
$backupFiles = [];
$processedFiles = 0;

/**
 * Enhanced pattern processor that handles closures and complex patterns
 */
function processPatterns($content, $patterns, $patternType = 'simple') {
    $updates = [];
    $needsCustomFieldsImport = false;
    
    foreach ($patterns as $pattern) {
        if (preg_match($pattern['pattern'], $content)) {
            if (is_callable($pattern['replacement'])) {
                // Handle closure-based replacements
                $content = preg_replace_callback($pattern['pattern'], $pattern['replacement'], $content);
            } else {
                // Handle simple string replacements  
                $content = preg_replace($pattern['pattern'], $pattern['replacement'], $content);
            }
            
            $updates[] = $pattern['description'];
            
            // Track if we need to add the CustomFields import
            if (isset($pattern['requiresImport'])) {
                $needsCustomFieldsImport = true;
            }
        }
    }
    
    return [$content, $updates, $needsCustomFieldsImport];
}

/**
 * Clean up imports - remove old ones and add new consolidated import
 */
function cleanupImports($content) {
    // Remove all old Custom Fields imports first
    $oldImports = [
        'Relaticle\CustomFields\Filament\Forms\Components\CustomFieldsComponent',
        'Relaticle\CustomFields\Filament\Infolists\CustomFieldsInfolists', 
        'Relaticle\CustomFields\Filament\Imports\CustomFieldsImporter',
        'Relaticle\CustomFields\Filament\Exports\CustomFieldsExporter',
        'Relaticle\CustomFields\Facades\CustomFields', // Also remove any existing facade imports
    ];
    
    foreach ($oldImports as $oldImport) {
        $content = preg_replace('/^use\s+' . preg_quote($oldImport, '/') . ';\s*\n/m', '', $content);
    }
    
    // Remove any duplicate/orphaned use statements
    $content = preg_replace('/^use\s*;\s*\n/m', '', $content);
    
    // Add single CustomFields facade import 
    $newImport = 'Relaticle\CustomFields\Facades\CustomFields';
    
    // Find the last use statement position
    if (preg_match('/^((?:use\s+[^;]+;\s*\n)*)/m', $content, $matches)) {
        // Insert after existing use statements
        $useSection = $matches[1];
        $content = str_replace(
            $useSection,
            $useSection . "use {$newImport};\n", 
            $content
        );
    } else {
        // No use statements exist, add after namespace or at the beginning
        if (preg_match('/(namespace\s+[^;]+;)/', $content)) {
            $content = preg_replace(
                '/(namespace\s+[^;]+;)/',
                "$1\n\nuse {$newImport};",
                $content,
                1
            );
        } else {
            // Add at the beginning after opening PHP tag
            $content = preg_replace(
                '/^(<\?php\s*\n)/m',
                "$1\nuse {$newImport};\n",
                $content,
                1
            );
        }
    }
    
    return $content;
}

/**
 * Check if file needs CustomFields import based on transformations made
 */
function needsCustomFieldsFacade($allUpdates) {
    $requiresImportPatterns = [
        'Form component usage',
        'Infolist component usage',
        'Importer',
        'Exporter'
    ];
    
    foreach ($allUpdates as $update) {
        foreach ($requiresImportPatterns as $pattern) {
            if (strpos($update, $pattern) !== false) {
                return true;
            }
        }
    }
    
    return false;
}

/**
 * Process multiline patterns that span across lines
 */
function processMultilinePatterns($content) {
    $updates = [];
    $needsImport = false;
    
    // Handle multiline CustomFieldsComponent patterns
    $multilineFormPattern = '/CustomFieldsComponent::make\(\)(\s*(?:\/\/[^\n]*\n)?(?:\s*->[a-zA-Z_][a-zA-Z0-9_]*\([^)]*\)(?:\s*(?:\/\/[^\n]*)?)*)*\s*)(?=,|\]|\)|;)/s';
    if (preg_match($multilineFormPattern, $content)) {
        $content = preg_replace_callback($multilineFormPattern, function($matches) {
            $chainedMethods = isset($matches[1]) ? $matches[1] : '';
            return 'CustomFields::form()
                ->forModel($form->getRecord())
                ->build()' . $chainedMethods;
        }, $content);
        $updates[] = 'Form component usage (multiline)';
        $needsImport = true;
    }
    
    // Handle multiline CustomFieldsInfolists patterns  
    $multilineInfolistPattern = '/CustomFieldsInfolists::make\(\)(\s*(?:\/\/[^\n]*\n)?(?:\s*->[a-zA-Z_][a-zA-Z0-9_]*\([^)]*\)(?:\s*(?:\/\/[^\n]*)?)*)*\s*)(?=,|\]|\)|;)/s';
    if (preg_match($multilineInfolistPattern, $content)) {
        $content = preg_replace_callback($multilineInfolistPattern, function($matches) {
            $chainedMethods = isset($matches[1]) ? $matches[1] : '';
            return 'CustomFields::infolist()
                ->forModel($infolist->getRecord())
                ->build()' . $chainedMethods;
        }, $content);
        $updates[] = 'Infolist component usage (multiline)';
        $needsImport = true;
    }
    
    // Handle multiline getColumnsByFieldCodes patterns
    $multilineFieldCodesPattern = '/\.\.\.app\(CustomFieldsImporter::class\)->getColumnsByFieldCodes\(\s*([^,\n]+),\s*(\[[^\]]+\])\s*\)/s';
    if (preg_match($multilineFieldCodesPattern, $content)) {
        $content = preg_replace($multilineFieldCodesPattern, '...CustomFields::importer()
            ->forModel($1)
            ->only($2)
            ->columns()', $content);
        $updates[] = 'Importer getColumnsByFieldCodes usage (multiline)';
        $needsImport = true;
    }
    
    return [$content, $updates, $needsImport];
}

/**
 * Upgrade configuration file from v1 to v2 format
 */
function upgradeConfigurationFile($basePath, $dryRun = false, $createBackup = false, $verbose = false) {
    // Config should be in the project root, not relative to scan path
    $configPath = $basePath . '/config/custom-fields.php';
    
    if (!file_exists($configPath)) {
        if ($verbose) {
            echo "‚ÑπÔ∏è  No config file found at: $configPath\n";
        }
        return false;
    }
    
    $content = file_get_contents($configPath);
    $originalContent = $content;
    
    // Check if it's already v2 format
    if (strpos($content, 'EntityConfigurator::') !== false || 
        strpos($content, 'FeatureConfigurator::') !== false || 
        strpos($content, 'FieldTypeConfigurator::') !== false) {
        if ($verbose) {
            echo "‚úÖ Config file already appears to be v2 format\n";
        }
        return false;
    }
    
    echo "üîß Upgrading configuration file...\n";
    
    // Create v2 configuration template
    $v2Config = '<?php

declare(strict_types=1);

use Relaticle\CustomFields\EntitySystem\EntityConfigurator;
use Relaticle\CustomFields\Enums\CustomFieldsFeature;
use Relaticle\CustomFields\FeatureSystem\FeatureConfigurator;
use Relaticle\CustomFields\FieldTypeSystem\FieldTypeConfigurator;

return [
    /*
    |--------------------------------------------------------------------------
    | Entity Configuration
    |--------------------------------------------------------------------------
    */
    \'entity_configuration\' => EntityConfigurator::configure()
        ->discover(app_path(\'Models\'))
        ->cache(false),

    /*
    |--------------------------------------------------------------------------
    | Advanced Field Type Configuration
    |--------------------------------------------------------------------------
    */
    \'field_type_configuration\' => FieldTypeConfigurator::configure()
        ->enabled([]) // Empty = all enabled
        ->disabled([]) // Add field types to disable
        ->discover(true)
        ->cache(enabled: false, ttl: 3400),

    /*
    |--------------------------------------------------------------------------
    | Features Configuration
    |--------------------------------------------------------------------------
    */
    \'features\' => FeatureConfigurator::configure()
        ->enable(
            CustomFieldsFeature::FIELD_ENCRYPTION,
            CustomFieldsFeature::UI_TABLE_COLUMNS,
            CustomFieldsFeature::UI_TOGGLEABLE_COLUMNS,
            CustomFieldsFeature::UI_TABLE_FILTERS,
            CustomFieldsFeature::SYSTEM_MANAGEMENT_INTERFACE
        )
        ->disable(
            CustomFieldsFeature::SYSTEM_MULTI_TENANCY
        ),

    /*
    |--------------------------------------------------------------------------
    | Management Interface Configuration
    |--------------------------------------------------------------------------
    */
    \'management\' => [
        \'slug\' => \'custom-fields\',
        \'navigation_sort\' => -1,
        \'navigation_group\' => true,
        \'cluster\' => null,
    ],

    /*
    |--------------------------------------------------------------------------
    | Database Configuration
    |--------------------------------------------------------------------------
    */
    \'database\' => [
        \'migrations_path\' => database_path(\'custom-fields\'),
        \'table_names\' => [
            \'custom_field_sections\' => \'custom_field_sections\',
            \'custom_fields\' => \'custom_fields\',
            \'custom_field_values\' => \'custom_field_values\',
            \'custom_field_options\' => \'custom_field_options\',
        ],
        \'column_names\' => [
            \'tenant_foreign_key\' => \'tenant_id\',
        ],
    ],
];
';

    if ($dryRun) {
        echo "üîç Would upgrade config file: config/custom-fields.php\n";
        if ($verbose) {
            echo "   - Convert v1 array format to v2 configurators\n";
            echo "   - Enable features based on v1 settings\n";
            echo "   - Add new v2 sections (entity_configuration, management, database)\n";
        }
        return true;
    } else {
        // Create backup if requested
        if ($createBackup) {
            $backupPath = createBackupFile($configPath);
            if ($backupPath) {
                echo "üíæ Config backup created: " . str_replace($basePath . '/', '', $backupPath) . "\n";
            }
        }
        
        // Write v2 config
        if (file_put_contents($configPath, $v2Config)) {
            echo "‚úÖ Config file upgraded to v2 format\n";
            if ($verbose) {
                echo "   - Converted to FeatureConfigurator, FieldTypeConfigurator, EntityConfigurator\n";
                echo "   - Added management and database sections\n";
                echo "   - Preserved encryption and table features\n";
            }
            return true;
        } else {
            echo "‚ùå Failed to write config file\n";
            return false;
        }
    }
}

// Process each file
foreach ($files as $filePath) {
    $processedFiles++;
    $content = file_get_contents($filePath);
    $originalContent = $content;
    $allUpdates = [];
    $needsCustomFieldsImport = false;

    // Show progress for large operations
    showProgress($processedFiles, count($files), basename($filePath));

    // Process import pattern updates
    [$content, $importUpdates, $needsImport1] = processPatterns($content, $importPatterns, 'imports');
    $allUpdates = array_merge($allUpdates, $importUpdates);
    $needsCustomFieldsImport = $needsCustomFieldsImport || $needsImport1;

    // Process complex component patterns
    [$content, $complexUpdates, $needsImport2] = processPatterns($content, $complexPatterns, 'complex');
    $allUpdates = array_merge($allUpdates, $complexUpdates);
    $needsCustomFieldsImport = $needsCustomFieldsImport || $needsImport2;

    // Process import/export patterns
    [$content, $importExportUpdates, $needsImport3] = processPatterns($content, $importExportPatterns, 'import-export');
    $allUpdates = array_merge($allUpdates, $importExportUpdates);
    $needsCustomFieldsImport = $needsCustomFieldsImport || $needsImport3;

    // Process multiline patterns
    [$content, $multilineUpdates, $needsImport4] = processMultilinePatterns($content);
    $allUpdates = array_merge($allUpdates, $multilineUpdates);
    $needsCustomFieldsImport = $needsCustomFieldsImport || $needsImport4;

    // Clean up imports if any Custom Fields transformations were made
    if ($needsCustomFieldsImport || needsCustomFieldsFacade($allUpdates)) {
        $content = cleanupImports($content);
    }

    // Save if changed
    if ($content !== $originalContent) {
        $relativePath = str_replace($basePath . '/', '', $filePath);

        if ($dryRun) {
            // Dry run mode - just show what would be changed
            echo "üîç Would update: $relativePath\n";
            foreach ($allUpdates as $update) {
                echo "   - $update\n";
            }
            if ($verbose) {
                echo "   üìÑ Preview of changes:\n";
                $diff = getDiffPreview($originalContent, $content);
                echo $diff . "\n";
            }
            $filesUpdated[$relativePath] = $allUpdates;
        } else {
            // Create backup if requested
            if ($createBackup) {
                $backupPath = createBackupFile($filePath);
                if ($backupPath) {
                    $backupFiles[] = $backupPath;
                    if ($verbose) {
                        echo "üíæ Backup created: $backupPath\n";
                    }
                } else {
                    echo "‚ö†Ô∏è  Warning: Could not create backup for $relativePath\n";
                }
            }

            // Write the actual changes
            if (file_put_contents($filePath, $content)) {
                $filesUpdated[$relativePath] = $allUpdates;
                echo "‚úÖ Updated: $relativePath\n";
                if ($verbose || count($allUpdates) <= 5) {
                    foreach ($allUpdates as $update) {
                        echo "   - $update\n";
                    }
                } else {
                    echo "   - " . count($allUpdates) . " changes made (use --verbose to see details)\n";
                }
            } else {
                $errors[] = $relativePath;
                echo "‚ùå Failed to update: $relativePath\n";
            }
        }
    } else if ($verbose) {
        echo "‚ö™ No changes needed: " . str_replace($basePath . '/', '', $filePath) . "\n";
    }
}

/**
 * Generate a simple diff preview
 */
function getDiffPreview($original, $new) {
    $originalLines = explode("\n", $original);
    $newLines = explode("\n", $new);
    $diff = "";
    $maxLines = 5; // Show max 5 lines of diff
    $lineCount = 0;
    
    for ($i = 0; $i < min(count($originalLines), count($newLines)) && $lineCount < $maxLines; $i++) {
        if ($originalLines[$i] !== $newLines[$i]) {
            $diff .= "     - " . trim($originalLines[$i]) . "\n";
            $diff .= "     + " . trim($newLines[$i]) . "\n";
            $lineCount++;
        }
    }
    
    if ($lineCount == $maxLines) {
        $diff .= "     ... (showing first $maxLines changes)\n";
    }
    
    return $diff;
}

// Show summary
echo "\n========================================\n";
if ($dryRun) {
    echo "üîç Dry Run Complete - No Files Modified\n";
} else {
    echo "üéâ Upgrade Process Complete!\n";
}
echo "========================================\n\n";

if (count($filesUpdated) > 0 || $configUpgraded) {
    if ($dryRun) {
        echo "üîç Changes that would be made:\n";
        if ($configUpgraded) echo "   ‚Ä¢ Configuration file (config/custom-fields.php)\n";
        echo "   ‚Ä¢ " . count($filesUpdated) . " PHP files\n\n";
        echo "Files that would be changed:\n";
    } else {
        echo "‚úÖ Upgrade completed:\n";
        if ($configUpgraded) echo "   ‚Ä¢ Configuration file upgraded\n";
        echo "   ‚Ä¢ " . count($filesUpdated) . " PHP files updated\n\n";
        echo "Updated files:\n";
    }
    
    foreach ($filesUpdated as $file => $updates) {
        echo "  ‚Ä¢ $file";
        if ($verbose) {
            echo " (" . count($updates) . " changes)";
        }
        echo "\n";
    }
} else {
    if ($configUpgraded) {
        echo "‚úÖ Configuration file upgraded. No PHP file changes needed!\n";
    } else {
        echo "‚úÖ No v1 components found. Your codebase appears to be already using v2!\n";
    }
}

// Show backup information
if (!$dryRun && $createBackup && count($backupFiles) > 0) {
    echo "\nüíæ Backup files created:\n";
    foreach ($backupFiles as $backupFile) {
        echo "  ‚Ä¢ " . str_replace($basePath . '/', '', $backupFile) . "\n";
    }
    echo "\nTo restore backups if needed:\n";
    echo "  find . -name '*.v1-backup-*' -exec sh -c 'mv \"\$1\" \"\${1%.v1-backup-*}\"' _ {} \\;\n";
}

if (count($errors) > 0) {
    echo "\n‚ö†Ô∏è  Errors encountered:\n";
    foreach ($errors as $file) {
        echo "  ‚Ä¢ $file\n";
    }
    echo "\nPlease review and fix these errors manually.\n";
}

// Next steps advice
echo "\n‚ú® Next Steps:\n";

if ($dryRun) {
    echo "üîç You ran in dry-run mode. To apply these changes:\n";
    echo "1. Run the upgrade script without --dry-run:\n";
    echo "   vendor/bin/custom-fields-upgrade";
    if (isset($options['path'])) {
        echo " --path=" . $options['path'];
    }
    if ($createBackup) {
        echo " --backup";
    }
    echo "\n\n";
    echo "2. Consider using --backup flag to create backups before changes\n";
} else if (count($filesUpdated) > 0) {
    echo "1. Clear Laravel caches:\n";
    echo "   php artisan cache:clear\n";
    echo "   php artisan config:clear\n";
    echo "   php artisan view:clear\n";
    echo "   php artisan filament:cache-components\n\n";
    
    echo "2. Review your configuration (config/custom-fields.php):\n";
    echo "   - Field types are now managed via 'field_type_configuration' using FieldTypeConfigurator\n";
    echo "   - Custom field types extend BaseFieldType and use FieldSchema (see docs)\n\n";
    
    echo "3. Review the updated files to ensure everything looks correct\n";
    echo "4. Run your test suite to verify functionality\n";
    echo "5. Check your Filament resources in the browser\n\n";
    
    if (count($backupFiles) > 0) {
        echo "6. Remove backup files after confirming everything works:\n";
        echo "   find . -name '*.v1-backup-*' -delete\n\n";
    }
} else {
    echo "üéâ No changes were needed - you're already using v2 syntax!\n";
    echo "You can still review your configuration and run cache clear commands if needed.\n\n";
}

echo "üìö For more information:\n";
echo "- Upgrade guide: https://custom-fields.dev/docs/v2/upgrade\n";
echo "- V2 documentation: https://custom-fields.dev/docs/v2/introduction\n";
echo "- Configuration: https://custom-fields.dev/docs/v2/essentials/configuration\n\n";

// Statistics
if ($verbose) {
    echo "üìä Upgrade Statistics:\n";
    echo "- Files scanned: " . count($files) . "\n";
    echo "- Files modified: " . count($filesUpdated) . "\n";
    echo "- Errors encountered: " . count($errors) . "\n";
    if (!$dryRun && $createBackup) {
        echo "- Backup files created: " . count($backupFiles) . "\n";
    }
    echo "\n";
}

exit(count($errors) > 0 ? 1 : 0);
